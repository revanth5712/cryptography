<!doctype html>
<html lang="en">
<head>
  <title>Text Encryption & Decryption Tool</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#9ca3af;color-scheme:dark}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%, #071827 60%);font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    .wrap{max-width:980px;margin:32px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    h1{margin:0 0 10px;color:white;font-size:20px}
    p.lead{margin:0 0 18px;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
    .card{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    textarea, input[type=text], select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef6;min-height:120px}
    textarea {resize:vertical}
    .row{display:flex;gap:8px}
    button{background:linear-gradient(90deg,var(--accent),#0ea5a3);border:none;padding:10px 12px;border-radius:8px;color:#06202a;font-weight:600;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:12px;color:var(--muted)}
    .controls {display:flex;gap:8px;align-items:center}
    .output{white-space:pre-wrap;word-break:break-word;min-height:120px}
    .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .footer{margin-top:12px;color:var(--muted);font-size:13px}
    .algo-note{font-size:12px;color:var(--muted);margin-top:8px}
    @media (max-width:880px){.grid{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Text Encryption & Decryption Tool</h1>

    <div class="grid">
      <div class="card">
        <label for="plaintext">Input text</label>
        <textarea id="plaintext" placeholder="Type or paste your message here..."></textarea>

            <label for="algorithm">Algorithm</label>
            <select id="algorithm">
              <option value="caesar">Caesar Cipher</option>
              <option value="mono">Monoalphabetic (substitution)</option>
              <option value="vigenere">Vigenère Cipher</option>
              <option value="playfair">Playfair Cipher</option>
            </select>

          <div style="width:200px">
            <label for="key">Key / Params</label>
            <input id="key" type="text" placeholder="Shift number or keyword" />
          </div>
        </div>

        <div class="controls" style="margin-top:12px">
          <button id="encryptBtn">Encrypt</button>
          <button id="decryptBtn">Decrypt</button>
          <button id="generateKeyBtn" title="Generate random monoalphabetic key">Generate Key</button>
          <div style="flex:1"></div>
        </div>

        <div class="algo-note" id="algoNote">Caesar uses numeric shift. Monoalphabetic expects a 26-letter key (or will be generated). Vigenère uses a text keyword. Playfair uses keyword; 'J' is merged with 'I'.</div>
      </div>

      <div class="card">
        <label for="output">Output</label>
        <div id="output" class="output" contenteditable="false" aria-live="polite"></div>

        <div class="actions">
          <button id="copyBtn">Copy</button>
          <button id="downloadBtn">Download</button>
          <button id="clearBtn">Clear</button>
        </div>

        <div class="footer">
          <div class="small">Notes: This tool is for learning/utility. For real security use vetted cryptography libraries and algorithms.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Utility helpers
    const $ = id => document.getElementById(id);
    const plaintext = $('plaintext');
    const algorithm = $('algorithm');
    const keyInput = $('key');
    const output = $('output');
    const encryptBtn = $('encryptBtn');
    const decryptBtn = $('decryptBtn');
    const copyBtn = $('copyBtn');
    const downloadBtn = $('downloadBtn');
    const clearBtn = $('clearBtn');
    const generateKeyBtn = $('generateKeyBtn');
    const algoNote = $('algoNote');

    // Event wiring
    algorithm.addEventListener('change', ()=>{
      const alg = algorithm.value;
      if(alg === 'caesar') keyInput.placeholder = 'Enter numeric shift (e.g. 3)';
      else if(alg === 'mono') keyInput.placeholder = '26-letter substitution key (optional)';
      else if(alg === 'vigenere') keyInput.placeholder = 'Enter keyword (letters only)';
      else if(alg === 'playfair') keyInput.placeholder = 'Enter keyword (letters only)';
    });

    generateKeyBtn.addEventListener('click', ()=>{
      if(algorithm.value === 'mono') keyInput.value = generateMonoKey();
      else alert('Generate Key button: only generates monoalphabetic substitution keys.');
    });

    encryptBtn.addEventListener('click', ()=>{ process(true); });
    decryptBtn.addEventListener('click', ()=>{ process(false); });
    copyBtn.addEventListener('click', copyOutput);
    downloadBtn.addEventListener('click', downloadOutput);
    clearBtn.addEventListener('click', ()=>{ plaintext.value=''; output.textContent=''; keyInput.value=''; });

    function setOutput(text){ output.textContent = text; }

    function process(isEncrypt){
      const text = plaintext.value || '';
      const alg = algorithm.value;
      const key = keyInput.value.trim();
      if(!text){ setOutput('⚠️ Please enter text to process.'); return; }

      try{
        let result = '';
        switch(alg){
          case 'caesar':
            const shift = parseInt(key,10);
            if(Number.isNaN(shift)) { alert('Caesar requires a numeric shift in key field.'); return; }
            result = caesar(text, isEncrypt ? shift : (26 - (shift % 26)));
            break;
          case 'mono':
            const monoKey = key.length === 26 ? key : generateMonoKey();
            if(key && key.length !== 26) alert('Provided monoalphabetic key is not 26 letters — a key will be generated instead.');
            result = mono(text, monoKey, isEncrypt);
            break;
          case 'vigenere':
            if(!key.match(/^[A-Za-z]+$/)) { alert('Vigenère requires an alphabetic keyword.'); return; }
            result = vigenere(text, key, isEncrypt);
            break;
          case 'playfair':
            if(!key.match(/^[A-Za-z]+$/)) { alert('Playfair requires an alphabetic keyword.'); return; }
            result = playfair(text, key, isEncrypt);
            break;
          default:
            result = 'Unsupported algorithm.';
        }
        setOutput(result);
      }catch(e){ setOutput('Error: '+String(e)); }
    }

    // ---------------- ALGORITHMS ----------------
    // Caesar cipher (preserve case, non-letters unchanged)
    function caesar(str, shift){
      shift = ((shift%26)+26)%26;
      let out = '';
      for(let ch of str){
        if(ch >= 'a' && ch <= 'z'){
          out += String.fromCharCode((ch.charCodeAt(0)-97+shift)%26+97);
        }else if(ch >= 'A' && ch <= 'Z'){
          out += String.fromCharCode((ch.charCodeAt(0)-65+shift)%26+65);
        }else out += ch;
      }
      return out;
    }

    // Monoalphabetic substitution. key is 26 letters representing mapping for 'A'..'Z'.
    function generateMonoKey(){
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      for(let i = letters.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [letters[i], letters[j]] = [letters[j], letters[i]];
      }
      return letters.join('');
    }

    function mono(text, key, encrypt=true){
      const mapEnc = {};
      const mapDec = {};
      const A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      key = key.toUpperCase();
      for(let i=0;i<26;i++){ mapEnc[A[i]] = key[i]; mapDec[key[i]] = A[i]; }
      let out='';
      for(let ch of text){
        const isLower = (ch >= 'a' && ch <= 'z');
        const isUpper = (ch >= 'A' && ch <= 'Z');
        if(isLower || isUpper){
          const up = ch.toUpperCase();
          const transformed = encrypt ? mapEnc[up] : mapDec[up];
          out += isLower ? transformed.toLowerCase() : transformed;
        }else out += ch;
      }
      return out;
    }

    // Vigenere cipher (A=0). Non-letters are preserved; key repeats over letters only.
    function vigenere(text, keyword, encrypt=true){
      const key = keyword.toUpperCase().replace(/[^A-Z]/g,'');
      let out=''; let ki=0;
      for(let ch of text){
        const isLower = (ch >= 'a' && ch <= 'z');
        const isUpper = (ch >= 'A' && ch <= 'Z');
        if(isLower || isUpper){
          const base = isLower?97:65;
          const pi = ch.charCodeAt(0)-base;
          const kiChar = key[ki % key.length];
          const kiVal = kiChar.charCodeAt(0) - 65;
          const ci = encrypt ? (pi + kiVal) % 26 : (pi - kiVal + 26) % 26;
          out += String.fromCharCode(ci + base);
          ki++;
        }else out += ch;
      }
      return out;
    }

    // ----- Playfair cipher implementation -----
    // Builds 5x5 key table (J merged with I). Prepares digrams for encryption/decryption.
    function buildPlayfairTable(key){
      key = key.toUpperCase().replace(/J/g,'I').replace(/[^A-Z]/g,'');
      const used = {};
      const table = [];
      for(let ch of key){ if(!used[ch]){ used[ch]=true; table.push(ch); } }
      for(let c=65;c<=90;c++){
        const ch = String.fromCharCode(c);
        if(ch === 'J') continue; // J merged with I
        if(!used[ch]){ used[ch]=true; table.push(ch); }
      }
      // table is 25 letters
      const grid = [];
      for(let r=0;r<5;r++) grid.push(table.slice(r*5, r*5+5));
      return grid;
    }

    function findPosition(grid, ch){
      // ch already normalized (J->I)
      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          if(grid[r][c] === ch) return {r,c};
        }
      }
      return null;
    }

    function preparePlayfairDigraphs(text){
      // Remove non-letters, uppercase, J->I
      let s = text.toUpperCase().replace(/[^A-Z]/g,'').replace(/J/g,'I');
      let pairs = [];
      let i=0;
      while(i < s.length){
        const a = s[i];
        let b = s[i+1];
        if(!b) { pairs.push([a,'X']); i+=1; }
        else if(a === b){ pairs.push([a,'X']); i+=1; }
        else { pairs.push([a,b]); i+=2; }
      }
      return pairs;
    }

    function playfair(text, key, encrypt=true){
      const grid = buildPlayfairTable(key);
      const pairs = preparePlayfairDigraphs(text);
      const outArr = [];
      for(const [a,b] of pairs){
        const pa = findPosition(grid, a);
        const pb = findPosition(grid, b);
        if(!pa || !pb) continue; // shouldn't happen
        let ra=pa.r, ca=pa.c, rb=pb.r, cb=pb.c;
        if(ra === rb){
          // same row
          if(encrypt){ ca = (ca+1)%5; cb = (cb+1)%5; }
          else { ca = (ca+4)%5; cb = (cb+4)%5; }
          outArr.push(grid[ra][ca] + grid[rb][cb]);
        }else if(ca === cb){
          // same column
          if(encrypt){ ra = (ra+1)%5; rb = (rb+1)%5; }
          else { ra = (ra+4)%5; rb = (rb+4)%5; }
          outArr.push(grid[ra][ca] + grid[rb][cb]);
        }else{
          // rectangle rule
          outArr.push(grid[ra][cb] + grid[rb][ca]);
        }
      }
      // Return grouped string with spaces between digrams
      return outArr.join(' ');
    }

    // ----------------- UI Helpers -----------------
    function copyOutput(){
      const text = output.textContent || '';
      if(!text) return alert('Nothing to copy');
      navigator.clipboard.writeText(text).then(()=>alert('Copied to clipboard'));
    }

    function downloadOutput(){
      const text = output.textContent || '';
      if(!text) return alert('Nothing to download');
      const blob = new Blob([text], {type:'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'ciphertext.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    // Initialize placeholders
    algorithm.dispatchEvent(new Event('change'));

  </script>
</body>
</html>
